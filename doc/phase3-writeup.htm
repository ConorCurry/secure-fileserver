<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>CS 1653 Project P3 Writeup</title>
  <style>
/* BEGIN CHANGES HERE */

/* In this section, you may add CSS styling if desired.
 * Be sure your writeup still prints legibly. */
header {
  text-align: center;
}

/* END CHANGES HERE */
  </style>
  <body>
    <header>
      <h1>CS 1653 Project P3 Writeup</h1>
      <h2>
<!-- BEGIN CHANGES HERE -->

Yijia Cui: yic66@pitt.edu       Conor Curry: clc231@pitt.edu

<!-- END CHANGES HERE -->
      </h2>
    </header>
    <section id="overview">
      <h2>Overview</h2>
<!-- BEGIN CHANGES HERE -->

<p>A single protocoal can never be sufficient to ensure the security of communications. The most common hybird protocl is the combination of asymmetric key crypotography and symmtric key crypotograhy. In our implementations of a secure file system, we use RSA public/private key encryption to achive the authentications between the users and the servers. An AES key (256-bit) will also be securely transmitted during the process of authentication, which will be used to protect the security of file contents and also user tokens. Furthermore, because the malicious modification of user tokens will lead to the unauthorized access to the file server, the verification of the tokens needs to be done. In our protocol, we concatenate each fields of the token and hash that string with SHA256 and sign the hashed string digitally with RSA key pairs.</p>

<!-- END CHANGES HERE -->
    </section>
    <section id="threat1">
      <h2>Threat T1: Unauthorized Token Issuance</h2>
<!-- BEGIN CHANGES HERE -->

<p>A user needs to acquire a token from the group server to access the group server and the file servers. However, it is not trustworthy that everyone who acquires the token is an authroized user. The system developed in phase 2 only needs a username to get a token from the group user, which is insesure because anyone can get that token as long as they know the username. If an adversary can know the username, he/she could access all the information related to that user stored on the group server and also all the files accessible to that username. As a result, the authentication of the user should be deployed before a token is issued. Also, the adversary can be a man in the middle, pretends to be the server and gets the messages passed from the user to the server, and then uses that information to pretend to be the user. Thus, it is also necessary for the system to authenticate the group server during this process.</p>

<p>The proposed mechanism for user authentication is the to use RSA public/private keys to exchange a nonce and AES symmetric key, which will used throughout the communication with the group server to protect tokens.We will use highly secure key sizes (3072-bit RSA and 256-bit AES).</p>

<p>Everytime the user needs to log into the system, the user needs to generate a random but large number for challenge, which will be encrypted by the server's public key. The user will generate a 256-bit AES symmetric key, encrypt it by the server's private key first and sign the encrypted key with his/her private key. The user will be asked to put in his/her username. That username needs to be concatenated with the encrypted number, the encrypted AES key, and the signed and encrypted AES key. Then, the concatenated message will be sent to the server side.</p>

<p> When the server receives this message, it will get the username and decrypt the encrypted number with its own private key. The server will search through its database to get the public key associated with this user. The server will use that public key to verify that the encrypted AES key is issued by the desired user, and then get the AES key through decryption with its private key. If the identity of the user is verified, the server will generate another random but large number, use the user's public key to encrypt that number, and send that encrypted number along with the decrypted number generated by the user. The server will send that message to the user. </p>

<p>When the user gets the message, he/she will verify whether the received number matches what they send, and decrypt the encrypted number with his/her own private key, and send the decrpyted number back to the server. If the server makes sure that that number matches the one it generated before, the mutal-authentication succeeds. And the user can use the AES symmetric key to start requesting token.</p>
<img src = "group_authentication.png" alt="Mountain View" style="width:400px;height:228px;">
<p>Through this mechanism, the authentication of both the user and the server is done by mutual verification of nonces. The exhange of AES symmetric key is done through the secure channel supported by RSA key pairs</p>

<p>The key exchanged protocol is secure. First, the user and the server will pick big and random numbers. Those numbers should be a 64-bit integer, which will lead to 2^64 possible values, making it hard for the adversary to guess in brute-force. During the process of exchanging, the user and the server encrypt messages with the other side's public key, and only the the other side knows the associated private key. As a result, no one can decrypt this message except themselves. The digital signature and the exchanges of challenges ensure that the messages are sent from the desired identity. Thus, the AES symmetric key is shared securely, and the user can use that shared key to encrypt the request. Since only the user and the server know the shared secret key, the token can be issued securely.</p>

<!-- END CHANGES HERE -->
    </section>
    <section id="threat2">
      <h2>Threat T2: Token Modification/Forgery</h2>
<!-- BEGIN CHANGES HERE -->

<p>The adversary might modify or forge tokes issused by the Group Server, and use those invalid tokens to access the files that they shouldn't have the privilege to see. Also, the information embedded in the user might be changed by the malicous users to access the group information that they are not members of that group, to access the file server with that modified message.</p>

<p> In order to assure the unchanged information inside the token, the hash function and the digital signature will be used to valid the token. When the server assigns the token to the user, it should concatenate the user name along with group names. The user name and group names will be separated by different delimiters, and those delimiters will be prohibited to use when new user names and group names are created. The concatenated string will be hashed by SHA-256, signed by the server's private key, and added as a new field of the token. When the file server or the third party receives the token, it will use the same principle to concatenate the username along with group names, hash it by SHA-256, and verify whether the field token is changed and signed by the group server. If the verfication succeeds, it means that the token hasn't been modified and was issued by the group server.</p>

<p>This mechanism is secure because only the server, the owner of the private key, can sign the message. If the user changes any information of that token, or the adversary forges one token, they can't create the digital signature because they don't know the server's private key. If they sign that message with a guessed private key, the file server, or the third-party, can find out that the message can't be verified. That is, if one or more fields are changed, and the token is no longer valid. Furthermore, signing a hashed string is more efficient than signing every field of the token.</p>
<!-- END CHANGES HERE -->
    </section>
    <section id="threat3">
      <h2>Threat T3: Unauthorized File Servers</h2>
<!-- BEGIN CHANGES HERE -->

<p>We must be assured that unauthorized file servers may not pose as legitimate servers. An illegitimate file server is a very serious security vulnerability, as it could easily perform man-in-the-middle attacks by impersonating the file server to the user, and impersonating the user to the file server. This would allow it to not only corrupt files, but modify them in transit, or even completely fabricate them. It would also break confidentiality by being able to see what files the user is requesting from the group server. It also would obviously be able to steal user tokens that were issued by the group server, seriously compromising user security.</p>
<p>The method we will use to confront these issues, and to properly authenticate the file server rely on a hybrid approach involving RSA’s public key cryptography, and AES symmetric keys. We will use highly secure key sizes (3072-bit RSA and 256-bit AES). The authentication between the user and file server will not leak information if trying to authenticate an unauthorized file server, and will be resistant to reflection attacks and man in the middle attacks. This protocol requires that the user is confident that they know the authentic file server’s public key before initiating the procedure. The authorization procedure is as follows:</p>
<p>The user’s cryptographic material includes the ticket (including ticket signature from the group server) for the user. This needs to remain secret to all except the user, group server, and authentic file servers. The user will also have a RSA keypair. </p>
<p>The file server’s cryptographic material also includes an RSA keypair. It will also have access to the group server’s public key, and will be expected to be able to create 256-bit securely random AES keys. </p>
<p>The authentication procedure begins with the user initiating a connection with the file server, and sending a secure random number, the user’s ticket (including signature), all encrypted with the server’s public key. This is concatenated with the user’s public key.</p>
<p>If authentic, the file server will be able to decrypt the random number and ticket material. The signed ticket will prove to the file server the authenticity of the user. Upon verification, and using the user’s provided public key, the file server will encrypt the user’s random number concatenated with a randomly generated AES256 key.</p>
<p>The user will then decrypt this message, and check equality of the provided random number with their own. If they match, this proves the validity of the file server to the user, and the two will be able to begin secured communication of messages and files using the provided AES256 session key.</p>
<p>As long as the user has access to the file server’s public key ahead of time, the server will be able to prove it’s authenticity using the random number challenge, and the server is able to authenticate the user, by commutativity. This is because the user has possession of a group server token, which means that the group server was able to properly perform entity authentication for the user.</p>

<!-- END CHANGES HERE -->
    </section>
    <section id="threat4">
      <h2>Threat T4: Information Leakage via Passive Monitoring</h2>
<!-- BEGIN CHANGES HERE -->

<p>Passive monitoring can easily break confidentiality guarantees that we want to provide. Information about the users’ identities, tokens, and files are all vulnerable to passive monitoring. AES256 symmetric key cryptography will be the method we use to provide secure communication channels. These keys will be shared via already described authentication procedures, and will allow for computationally efficient secure communication (as opposed to attempting to encrypt large files with RSA).</p>
<p>We will use AES256 in OFB mode to secure the required message and file communication. OFB mode is useful for allowing precomputation of the encryption, which will allow speedy file access from the server, and reduces redundant recomputation of encryption. This will help reduce load and prevent denial of service attacks against file servers. These session keys are shared in the authentication procedure between the respective server and the user, and are randomly generated each time a authenticates. This will prevent attacks resulting from key overuse. </p>
<p>Because the AES keys are shared during secure authentication, only the user and the server will be able to decrypt the messages and files sent between them. This will successfully address the problem of passive monitoring, by creating a secure tunnel for communication between the user and server.</p>


<!-- END CHANGES HERE -->
    </section>
    <section id="discussion">
      <h2>Discussion</h2>
<!-- BEGIN CHANGES HERE -->

<p>Conclude with a paragraph or two discussing the interplay between your
proposed mechanisms, and commenting on the design process that your group
followed. Did you discuss other ideas that didnâ€™t pan out before settling on the
above-documented approach? Did you end up designing a really interesting
protocol suite that addresses multiple threats at once? Use this space to show
off your hard work!</p>

<p>In this phase, we have implemented lots of extra credits.</p>
<p>First, we have fixed the least privilege principle in phase2. We add the function that the user needs to select the group they want to work on, and the group server will re-issue them a token only with the groups they have requested. If they would like to switch to other groups, they need to re-select the groups again, and the group server will replace the user's token with the new one.</p>

<p>Second, we have implemented challenges with RSA key pairs for the mutual-authentication between the users and the group server. This implementation saves the space to store the users' password(or hashed password).</p>

<p>Lastly, we have implemented secure storage of private keys. Instead of storing private keys directly, we ask the user/the server for a password, which will be hashed and salted, working as a secret key, to encrypt the private keys. And we will store those encrypted private keys and associated salt values into files. Next time, if the users/the server need their own private key, they need to put their password to generate the same secrete key and recover the private key.</p>
<!-- END CHANGES HERE -->
    </section>
  </body>
</html>
