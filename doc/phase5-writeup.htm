<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>CS 1653 Project P5 Writeup</title>
  <style>
/* BEGIN CHANGES HERE */

/* In this section, you may add CSS styling if desired */
header {
  text-align: center;
}

/* END CHANGES HERE */
  </style>
  <body>
    <header>
      <h1>CS 1653 Project P5 Writeup</h1>
      <h2>
<!-- BEGIN CHANGES HERE -->

Yijia Cui yic66@pitt.edu, Conor Curry clc231@pitt.edu

<!-- END CHANGES HERE -->
      </h2>
    </header>
    <section id="overview">
      <h2>Overview</h2>
<!-- BEGIN CHANGES HERE -->

<p>In this section, broadly overview your threat model, attacks, and
countermeasures.</p>

<!-- END CHANGES HERE -->
    </section>
    <section id="threatmodel">
      <h2>Threat Model: Information Leakage/ modification from Servers’ and Users’ disks</h2>
<!-- BEGIN CHANGES HERE -->

<h3>Description:</h3> 
<p>Even though group server is mostly trusted in the system, but all the information stored on group server is unencrypted as plain text files, which is very vulnerable.  Attackers are assumed to be able to steal those information files from the disk of group server. Also, users and servers store their private keys locally, which is encrypted by a key derived from the password they set up with SHA-256. Because of the fast speed of hardwares, attackers can break SHA-256 keys brute-forcedly using dictionary and rainbow tables within reasonable time and steal/modify the private keys once the file is decrypted. Thus, a secure encryption should be added to files stored on the group server’s and users’ disks to ensure the confidentiality of those important information.</p>

<!-- END CHANGES HERE -->
    </section>
    <section id="attack">
      <h2>Attacks</h2>
<!-- BEGIN CHANGES HERE -->

<h3>For Group Server:</h3>
<p>The adversary can add any person into one group by modifying UserList file and GroupList file, which will give the malicious user permission to read/write files only shared within those groups. Also, the adversary can remove any person from groups to disenable them from accessing files.</p>

<p>The adversary can get list of files keys by compromising the plaintext storing that information. The leakage of file keys can lead to the unauthorized access to files that should only be accessed to members in a certain group. The adversary can read and modify files with the stolen key lists because file servers are untrusted and can leak files encrypted by keys in the lists. The adversary can even modify the key list to mess up users that they can’t decrypt the files appropriately with wrong keys. </p>

<p>The adversary can even change public keys stored in the UserList to mess up the authentication process between the user and the group server. </p>

<h3>For stored private keys:</h3>
<p>The adversary can steal encrypted private keys (with SHA-256) stored in disk and break that file to get the private key. This threat leads to the private keys being compromised. The authentication is done by RSA key pairs. Once the private key is compromised, the exchanged shared key is revealed, and all the conversation will be presented to the adversary.</p>

<!-- END CHANGES HERE -->
    </section>
    <section id="countermeasure">
      <h2>Countermeasures</h2>
<!-- BEGIN CHANGES HERE -->

<p>Instead of using keys derived from passwords with SHA-256 to encrypt private keys, the new algorithm, PBKDF2WithHmacSHA1, is used to derive keys from passwords. The iteration number of this algorithm makes it slow to break by design, to make the attack hard to achieve. 
With those keys, users and servers can store their private keys safely to reduce the possibility that private keys are compromised. Those keys can also use to encrypt important files on the servers, for example, the GroupList and UserList on the group server. The adversary could not access information encrypted in the files because of the difficulty of attacking, which prevents information being modified/leaked, like group information, file key lists, etc. 
</p>
    </section>
    <section id="threatmodel">
      <h2>Threat Model: Forward Secrecy Broken</h2>
<h3>Description:</h3> 
<p>In previous threat models, the possibility for a private key being compromised is brought up. The adversary may record all the information starting from the authentication process and break all the messages exchanged. The forward secrecy was broken in this case.</p>

</section>
    <section id="attack">
      <h2>Attacks</h2>
<p>The adversary compromises the private key first and records all the messages exchanged between the innocent user and server. Then the adversary will use the private key to get the key exchanged between them, and decrypts all the messages. That decryption of message no only reveals all the information exchanged, it also reveals the list of keys being transmitted to the user if the user requests such a list from group server.  Some files are encrypted with keys with in the list, and the adversary can use that list of file keys to decrypt those files stolen from file servers (they are untrusted). </p>

</section>
    <section id="countermeasure">
      <h2>Countermeasures</h2>
<p>Signed Diffie-Hellman will be used through the authentication and key exchanges. (Implemented)</p>

</section>
    <section id="threatmodel">
      <h2>Threat Model: DoS Attack</h2>
<h3> Description:</h3>
<p>A denial-of-service (DoS) attack can be an attmpt to make a machine unavailable to intended users. Even though the number of threads and the storage of disk are enough for legitimate uses, the adversary can make requests to consume the server’s resources and prevent real users from using those resources. </p>

</section>
    <section id="attack">
      <h2>Attacks</h2>
<p>The adversary may develop a driver to send requests only. For example, the adversary can write a program to send authentication/operation request only and never responds to the server’s reply. Because the server uses threads to communicate with different clients and a computer can support only a limited number of threads (the number may vary from computer to computer). If an adversary run such a driver multiple times until the number of threads are consumed completely on the server, no more client can connect to the server.  </p>
<p>The adversary can also consume the disk of the file server by keeping uploading huge files. Once the storage of a file server is filled up, no more files can be uploaded by legitimate users.</p>
</section>
    <section id="countermeasure">
      <h2>Countermeasures</h2>
<p>The server can close the connection with a client automatically if the client does not respond in 5 minutes. This number is reasonable because that the operations are simple enough for users to perform. If they fail to response to the interactions, they have to re-log in.</p>

<p>The server can assign file quota to the groups.</p>

<section id="threatmodel">
  <h2>Threat Model: Compromised User Keys</h2>
  <h3>Description:</h3>
  <p>Currently, a major weakness of our system is the use of long term secrets – in the form of RSA keypairs – for authentication and user identification. Furthermore, while inadvisable, there is currently no way to prevent users from using a particular keypair for more than one application. Therefore, there is a large potential for these keys to be compromised over their lifetime. To fix these issues, we propose the addition of a key revocation system, as well as the ability for users to use multiple keypairs to identify themselves to the groupserver. The ability of a user to have multiple keypairs ensures they will still have access to their account in the event that one must be revoked or has been stolen. This threat motivates the creation of multiple privilege levels when interacting with a Group Server. This allows the user to work in two modes. One is mode that reflects our current implementation, where the user can request file server tokens and perform actions that may arise during normal use of the system. However, they should also be given a method for performing a privilege escalation, in order to perform administrative actions on their account. These actions include adding new authorized keys as well as revoking keys. </p>

  <h3>Attacks:</h3>
  <p>A determined attacker may find several ways to compromise keys, and most of these cannot be prevented from the perspective of the servers or client application. Without out-of-band organizational policy, there is no way that our application can enforce users using key exclusive to our application. This means that there are nearly unlimited ways that an attacker could steal a user's keys, perhaps with another application that had a compromised authentication method. Key compromise could be as simple as stealing the user's storage device – or their whole laptop. While we attempt to mitigate this threat by password protecting keys on disk, it would be detrimental to assume that no user's key could ever be stolen. It is not a “what-if” as much as a “when” in a system of any appreciable size.</p>
  <p>Once a malicious actor has access to a legitimate user's keypair, the attacks are again quite simple. Keys form the backbone of our system's authentication mechanism, and a stolen keypair enables the complete impersonation of a user. This would allow an attacker to access, modify, and delete files in that user's groups – breaking confidentiality and integrity assumptions. In addition, it may be possible to perform “internal DoS attacks”. These could be characterized by creating many groups, or sending many requests as an already authenticated user in an attempt to overwhelm the group server. They also could fill the File Server with garbage data files, filling its storage capacity and preventing legitimate groups from storing new files.</p>
  <p>Again, the crux of this threat is that it enables an attacker to perform these actions <em>while being a properly authenticated entity.</em> By impersonating a legitimate user, it becomes much harder for many potential DoS prevention mechanisms to filter out malicious requests from legitimate ones.</p>

  <h3>Countermeasures:</h3>
  <p>A multiple key policy is the basis of our proposed solution to the key compromise threat. With multiple keys, users are able to more easily revoke and rotate their keys intermittently. It also means that an attacker will have to expend much more effort to steal information that could lock a user out of their account. This is due to a privilege escalation policy, that may be implemented by two different mechanisms: the Administrative Key mechanism and the Key Quorum mechanism. Each provides a policy of privilege escalation for critical account management tasks – namely key addition and revocation.</p>
  <p>First we look at the Administrative Key mechanism. In a system implementing this, each user designates a key that is expected to be kept more secure than a normal user key. When making a request for administrative action, the user will engage in the protocol illustrated here.</p>

  <img src = "AdminKey.png" alt="Administrative User Key Protocol" style="width:879px;height:552px;">

  <p>Only a single message must be sent to the Group Server after initiating the request. It is assumed here that the user has already authenticated themselves and has a mutually agreed upon session key and HMAC key. The structure of the addition certificate itself is necessarily small, as it must be signed by a 3072 bit RSA key. Therefore, it is simply the text “ADDCERT” concatenated with the SHA-256 fingerprint of the key the user wishes to add; or “REVCERT” for a user wishing to revoke a key. This means it is easy for a user to generate addition and revocation certificates, and the Group Server does not need to keep a record of issuing certificates or be involved in their distribution to clients. One of the major drawbacks of the Administrative Key approach is the single point of attack for a malicious entity. The Administrative Key itself represents a very high value target, and one which will be able to override the true user's authority if it is stolen. </p>
  <p>Key Quorum administration operates under the assumption of a user having a set of keys which they use in different situations, and on different devices. This means it is unlikely that an attacker will get a large amount of key material, yet the user should be able to collect their keys in the event of needing to take administrative action. This approach may be advantageous in a scenario where an organization issues hardware tokens containing user keys. This makes it more psychologically acceptable to keep them physically separated, and humans are more used to keeping items physically secure than data.</p>
  <p>The principles of the Key Quorum method are similar to that of the Administrative Key. In fact, it provides the same policy of account administration, but instead of relying on a single high-privilege key; the privilege requires a critical mass of keys at once. Let us examine a particular scenario, where the “Quorum number” is 3, and the user has 5 keys used for several different usage scenarios. Let us further assume that an attacker has managed to steal one key – and thereby deprive the user of it. This malicious entity will be able to properly authenticate with the group server and use the file server in malicious ways. However, they will not be able to perform administrative actions on the account. They will not be permitted to add keys of their own, and they will not be permitted to revoke the already approved keys of the user. The user however, upon noticing this theft, will simply gather three of their keys, authenticate with the Group Server, request key revocation and engage in the protocol illustrated here.</p>

  <img src="KeyQuorum.png" alt="Key Quorum Administrative Protocol" style="width:879px;height:552px;">

  <p>The Group Server need only verify several levels of keys (in the correct specified order) in order to verify the request as a whole, and it will then revoke the compromised key. The Group Server's verification process will proceed by matching the given keys to those it has associated with the user (if it can). It does not directly use the provided keys to verify the signatures on the certificate. After revocation has completed, the user may then generate a new key to replace the stolen one, and the attacker will have only gained transient access to the system. With appropriate logging mechanisms, any changes made by the malicious user could be easily noticed and reverted, and normal operation could resume after only a small inconvenience.</p>
  <p>An important parameter to select is the Quorum number. This should be high enough so that a malicious entity will be hard-pressed to steal a critical number of keys, yet low enough to not be overly cumbersome for the user. It should also depend on how many keys that user has attached to their account. This method could also provide a feedback loop of difficulty for the user, so that adding a new key becomes harder the more keys they have already added. This can be in turn be tuned in a practical situation to prevent a user having too many keys to keep track of, leading to a more trivial task of an attacker to steal them. However this does not also preclude the option of introducing a hard limit for the number of keys, which would also be effective in preventing "key inflation"</p>
  

<!-- END CHANGES HERE -->
    </section>
    <section id="discussion">
      <h2>Discussion</h2>
<!-- BEGIN CHANGES HERE -->

<p>Conclude with a paragraph or two discussing your threat model and
countermeasure mechanisms. How realistic is your threat model for a real-life
file sharing system? Comment on the design process that your group followed. Did
you discuss other ideas that didn’t pan out before settling on the
above-documented approach? Did you design attacks that you were unable to
mitigate, or that you think are impossible to mitigate? Use this space to show
off your hard work!</p>

<p>Finally, spend a paragraph discussing the interplay between the
countermeasures for your proposed attacks and your techniques for mitigating
threats T1–T7 from Phases P3 and P4 of the project. Did you have to design your
countermeasures in a particular way so as not to re-introduce these older
threats?</p>

<p>If your group implemented the countermeasures or did any extra credit, please
discuss these additional contributions in this section, as well.</p>

<!-- END CHANGES HERE -->
    </section>
  </body>
</html>
